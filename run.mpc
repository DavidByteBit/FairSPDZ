# In its current state, this code will not work as it requires other scripts to populate the parties input files.
# This code simply serves as an example of code in MP-SPDZ. It is unoptimized, and not modular. As such, it should
# not serve as an example of what 'good' MP-SPDZ code should look like, just what it can look like.

from Compiler import mpc_math
from Compiler import ml
from Compiler import models
# from Compiler.library import public_input()

# program.options_from_args()
#
# try:
#     num_of_parties= int(program.args[1])
#     model_owner_id= int(program.args[2])
#     model_type = program.args[3]
#     all_metadata = program.args[4]
# except:
#     print("WARNING - Could not read args correctly")
#     raise Exception

# @args - Public inputs
settings_map = {}

model_type = settings_map['model_type']

if 5 == 5:
    print_ln("hello")

if model_type == "lr":
    all_metadata = settings_map['all_metadata']
    model_owner_id = settings_map['model_owner_id']
    num_of_parties = settings_map['num_of_parties']

    lr = models.logistic_regression(all_metadata, model_owner_id)
    classifications = lr.classify()
    print_ln("%s", classifications.reveal())


def dot_product(a, b):  # The Array class has a dot product, should use that
    assert (len(a) == len(b))

    res = sint(0)
    for i in range(len(a)):
        res += a[i] * b[i]

    return res


# Loads in model parameters from Alice
def load_model(param_size):
    model_coefs = Array(param_size - 1, sfix)

    @for_range_opt(param_size - 1)
    def _(i):
        model_coefs[i] = sfix.get_input_from(ALICE)

    bias = sfix.get_input_from(ALICE)

    return (model_coefs, bias)


# Loads in dataset from Bob
def load_data(param_size, row_length):
    # Note that 'param_size - 1' should be the number of features of the dataset
    data = Matrix(row_length, param_size - 1, sfix)

    @for_range_opt(row_length)
    def _(i):
        @for_range_opt(param_size - 1)
        def _(j):
            data[i][j] = sfix.get_input_from(BOB)

    return data


# Loads in corresponding labels to dataset from Bob
def get_labels(row_length):
    labels = Array(row_length, sint)

    @for_range_opt(row_length)
    def _(i):
        labels[i] = sint.get_input_from(BOB)

    return labels


# Securely classify data
def infer_data(model, data, param_size, row_length):
    threshold = sfix(0.0)
    predicted_labels = Array(row_length, sint)

    @for_range_opt(row_length)
    def _(i):
        label_intermediate = dot_product(model[0], data[i]) + model[1]
        label = threshold >= label_intermediate
        predicted_labels[i] = label

    return predicted_labels





# model.classify(encrypted_data)

# Command line arguments do not work, so this code is no good
# 0: Number of Params, 1: Number of rows in data
# args = sys.argv[1:]

# i = 0
# while not args[i].__eq__('-'):
#     i += 1
#
# args = args[i + 1:]

# num_of_params = int(args[0])
# row_length = int(args[1])

model = load_model(num_of_params)

data = load_data(num_of_params, row_length)

predicted_labels = infer_data(model, data, num_of_params, row_length)

actual_labels = get_labels(row_length)

TP = sint(0)
FP = sint(0)
TN = sint(0)
FN = sint(0)

# Count correctly and incorrectly classified labels
for i in range(row_length):
    a = predicted_labels[i]
    b = actual_labels[i]

    x = (a == sint(1))
    y = (b == sint(1))
    z = sint(1) - x
    w = sint(1) - y

    TN += z * w
    FP += z * b
    FN += x * w
    TP += x * y

# Not working yet
print_ln('TP for%s:%s', "Bob", TP.reveal())
print_ln('FP for%s:%s', "Bob", FP.reveal())
print_ln('FN for%s:%s', "Bob", FN.reveal())
print_ln('TN for%s:%s', "Bob", TN.reveal())

# Not working yet
print_ln_to(BOB, 'TP for%s:%s', "Bob", TP.reveal_to(BOB))
print_ln_to(BOB, 'FP for%s:%s', "Bob", FP.reveal_to(BOB))
print_ln_to(BOB, 'FN for%s:%s', "Bob", FN.reveal_to(BOB))
print_ln_to(BOB, 'TN for%s:%s', "Bob", TN.reveal_to(BOB))





